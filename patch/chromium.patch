From d7bb06f4f17d0729dc31dc9674a3e8567d352e2a Mon Sep 17 00:00:00 2001
From: Dmitrii Pichulin <deem@deem.ru>
Date: Fri, 2 Sep 2016 14:25:18 +0300
Subject: [PATCH] added GOSTSSL

---
 .../ui/views/ssl_client_certificate_selector.cc    |   3 +-
 .../common/chromium-browser/chromium-browser.info  |  10 +-
 chrome/installer/linux/common/installer.include    |   3 +
 chrome/installer/linux/rpm/chrome.spec.template    |   4 +
 .../ssl_config/ssl_config_service_manager_pref.cc  |   2 +-
 net/base/net_error_list.h                          |   6 +
 net/cert/cert_verify_proc.cc                       |  56 +++++++++
 net/http/http_network_transaction.cc               |   8 ++
 net/socket/ssl_client_socket_impl.cc               | 129 +++++++++++++++++++++
 net/ssl/client_cert_store_nss.cc                   |  46 ++++++++
 net/ssl/openssl_ssl_util.cc                        |   4 +
 net/ssl/ssl_cipher_suite_names.cc                  |  22 ++++
 12 files changed, 286 insertions(+), 7 deletions(-)

diff --git a/chrome/browser/ui/views/ssl_client_certificate_selector.cc b/chrome/browser/ui/views/ssl_client_certificate_selector.cc
index 0830efb..2787539 100644
--- a/chrome/browser/ui/views/ssl_client_certificate_selector.cc
+++ b/chrome/browser/ui/views/ssl_client_certificate_selector.cc
@@ -69,7 +69,8 @@ bool SSLClientCertificateSelector::Accept() {
     // notification while waiting for the unlock dialog, causing us to delete
     // ourself before the Unlocked callback gets called.
     StopObserving();
-#if defined(USE_NSS_CERTS) && !defined(OS_CHROMEOS)
+#define GOSTSSL
+#if !defined(GOSTSSL) && defined(USE_NSS_CERTS) && !defined(OS_CHROMEOS)
     chrome::UnlockCertSlotIfNecessary(
         cert.get(), chrome::kCryptoModulePasswordClientAuth,
         cert_request_info()->host_and_port, GetWidget()->GetNativeView(),
diff --git a/chrome/installer/linux/common/chromium-browser/chromium-browser.info b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
index 3593c9e..9826523 100644
--- a/chrome/installer/linux/common/chromium-browser/chromium-browser.info
+++ b/chrome/installer/linux/common/chromium-browser/chromium-browser.info
@@ -6,22 +6,22 @@
 # chromium-browser packages for various platforms.
 
 # Base name of the package.
-PACKAGE="chromium-browser"
+PACKAGE="chromium-gost"
 
 # Filename of the main executable (for generating launcher scripts, etc.)
 PROGNAME=chrome
 
 # Base directory for package installation.
-INSTALLDIR=/opt/chromium.org/chromium
+INSTALLDIR=/opt/chromium-gost
 
 # Display string for desktop menu/icon.
-MENUNAME="Chromium Web Browser"
+MENUNAME="chromium-gost"
 
 # Brief package description.
-SHORTDESC="The web browser from Chromium.org"
+SHORTDESC="Chromium browser with GOST cryptography support"
 
 # Detailed package description.
-FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier."
+FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier. This version supports GOST cryptography in TLS-connections."
 
 # Package maintainer information.
 # TODO(mmoss) Setup a mailbox for this address
diff --git a/chrome/installer/linux/common/installer.include b/chrome/installer/linux/common/installer.include
index d606238..4130b76 100644
--- a/chrome/installer/linux/common/installer.include
+++ b/chrome/installer/linux/common/installer.include
@@ -162,6 +162,9 @@ stage_install_common() {
     install -m 644 "${BUILDDIR}/libwidevinecdm.so" "${STAGEDIR}/${INSTALLDIR}/"
   fi
 
+  # GOSTSSL
+  install -m 644 "${BUILDDIR}/gostssl.so" "${STAGEDIR}/${INSTALLDIR}/"
+
   # ANGLE
   if [ "${CHANNEL}" != "stable" ]; then
     install -m 644 "${BUILDDIR}/libGLESv2.so" "${STAGEDIR}/${INSTALLDIR}/"
diff --git a/chrome/installer/linux/rpm/chrome.spec.template b/chrome/installer/linux/rpm/chrome.spec.template
index 08c402c..433e6f6 100644
--- a/chrome/installer/linux/rpm/chrome.spec.template
+++ b/chrome/installer/linux/rpm/chrome.spec.template
@@ -120,6 +120,8 @@ add_nss_symlinks
 
 remove_udev_symlinks
 
+if false; then
+
 DEFAULTS_FILE="/etc/default/@@PACKAGE@@"
 if [ ! -e "$DEFAULTS_FILE" ]; then
   echo 'repo_add_once="true"' > "$DEFAULTS_FILE"
@@ -155,6 +157,8 @@ fi
 service atd start
 echo "sh /etc/cron.daily/@@PACKAGE@@" | at now + 2 minute > /dev/null 2>&1
 
+fi
+
 CHANNEL=@@CHANNEL@@
 case $CHANNEL in
   stable )
diff --git a/components/ssl_config/ssl_config_service_manager_pref.cc b/components/ssl_config/ssl_config_service_manager_pref.cc
index ee63047..e389cdf 100644
--- a/components/ssl_config/ssl_config_service_manager_pref.cc
+++ b/components/ssl_config/ssl_config_service_manager_pref.cc
@@ -243,7 +243,7 @@ void SSLConfigServiceManagerPref::RegisterPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(ssl_config::prefs::kCertEnableSha1LocalAnchors,
                                 false);
   registry->RegisterBooleanPref(
-      ssl_config::prefs::kCertEnableCommonNameFallbackLocalAnchors, false);
+      ssl_config::prefs::kCertEnableCommonNameFallbackLocalAnchors, true);
   registry->RegisterStringPref(ssl_config::prefs::kSSLVersionMin,
                                std::string());
   registry->RegisterStringPref(ssl_config::prefs::kSSLVersionMax,
diff --git a/net/base/net_error_list.h b/net/base/net_error_list.h
index 617a56d..f5007d5 100644
--- a/net/base/net_error_list.h
+++ b/net/base/net_error_list.h
@@ -19,6 +19,12 @@
 //   700-799 Certificate manager errors
 //   800-899 DNS resolver errors
 
+#define GOSTSSL
+#if defined(GOSTSSL)
+//   3000-3099 GOSTSSL
+NET_ERROR(TLS_GOST_REQUIRED, -3072)
+#endif // GOSTSSL
+
 // An asynchronous IO operation is not yet complete.  This usually does not
 // indicate a fatal error.  Typically this error will be generated as a
 // notification to wait for some external notification that the IO operation
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index da49688..3af087a 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -519,6 +519,27 @@ CertVerifyProc* CertVerifyProc::CreateDefault() {
 #endif
 }
 
+#ifdef GOSTSSL
+#ifdef _WIN32
+#if defined ( _M_IX86 )
+#define EXPLICITSSL_CALL __cdecl
+#elif defined ( _M_X64 )
+#define EXPLICITSSL_CALL __fastcall
+#endif
+#define GOSTSSLLIB "gostssl.dll"
+#define LIBLOAD( name ) LoadLibraryA( name )
+#define LIBFUNC( lib, name ) (UINT_PTR)GetProcAddress( lib, name )
+#else // not _WIN32
+#define EXPLICITSSL_CALL
+#include <dlfcn.h>
+#define GOSTSSLLIB "gostssl.so"
+#define LIBLOAD( name ) dlopen( name, RTLD_LAZY )
+#define LIBFUNC( lib, name ) dlsym( lib, name )
+typedef void * HMODULE;
+#endif // _WIN32
+#endif // GOSTSSL
+
+
 CertVerifyProc::CertVerifyProc()
     : sha1_legacy_mode_enabled(base::FeatureList::IsEnabled(kSHA1LegacyMode)) {}
 
@@ -549,6 +570,41 @@ int CertVerifyProc::Verify(X509Certificate* cert,
   int rv = VerifyInternal(cert, hostname, ocsp_response, flags, crl_set,
                           additional_trust_anchors, verify_result);
 
+#if defined(GOSTSSL)
+  int is_gost = 0;
+  {
+      static void ( EXPLICITSSL_CALL * isgostcerthook )( void * cert, int size, int * is_gost ) = NULL;
+      static int is_tried = 0;
+
+      if( !is_tried )
+      {
+          HMODULE hGSSL = LIBLOAD( GOSTSSLLIB );
+
+          if( hGSSL )
+              *(uintptr_t *)&isgostcerthook = (uintptr_t)LIBFUNC( hGSSL, "gostssl_isgostcerthook" );
+
+          is_tried = 1;
+      }
+
+      if( isgostcerthook )
+      {
+#ifdef OPENSSL_WINDOWS
+          isgostcerthook( (void *)cert->os_cert_handle(), 0, &is_gost );
+#else // not OPENSSL_WINDOWS
+          std::string cert_pem;
+          if( cert->GetDEREncoded( cert->os_cert_handle(), &cert_pem ) )
+              isgostcerthook( (void *)&cert_pem[0], cert_pem.size(), &is_gost );
+#endif // OPENSSL_WINDOWS
+      }
+  }
+
+  if( is_gost == 1 )
+  {
+      // TODO: we can check for weak GOST algos after 2018
+  }
+  else
+#endif // GOSTSSL
+
   // Check for mismatched signature algorithms and unknown signature algorithms
   // in the chain. Also fills in the has_* booleans for the digest algorithms
   // present in the chain.
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index a5395d7..24355b3 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -1484,6 +1484,14 @@ int HttpNetworkTransaction::HandleSSLHandshakeError(int error) {
   DCHECK(request_);
   HandleClientAuthError(error);
 
+#if defined(GOSTSSL)
+  if( error == ERR_TLS_GOST_REQUIRED )
+  {
+    ResetConnectionAndRequestForResend();
+    return OK;
+  }
+#endif // GOSTSSL
+
   // Accept deprecated cipher suites, but only on a fallback. This makes UMA
   // reflect servers require a deprecated cipher rather than merely prefer
   // it. This, however, has no security benefit until the ciphers are actually
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
index a81e331..0ff9a1b 100644
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -1143,6 +1143,26 @@ int SSLClientSocketImpl::DoHandshake() {
   return net_error;
 }
 
+#ifdef GOSTSSL
+#ifdef _WIN32
+#if defined ( _M_IX86 )
+#define EXPLICITSSL_CALL __cdecl
+#elif defined ( _M_X64 )
+#define EXPLICITSSL_CALL __fastcall
+#endif
+#define GOSTSSLLIB "gostssl.dll"
+#define LIBLOAD( name ) LoadLibraryA( name )
+#define LIBFUNC( lib, name ) (UINT_PTR)GetProcAddress( lib, name )
+#else // not _WIN32
+#define EXPLICITSSL_CALL
+#include <dlfcn.h>
+#define GOSTSSLLIB "gostssl.so"
+#define LIBLOAD( name ) dlopen( name, RTLD_LAZY )
+#define LIBFUNC( lib, name ) dlsym( lib, name )
+typedef void * HMODULE;
+#endif // _WIN32
+#endif // GOSTSSL
+
 int SSLClientSocketImpl::DoHandshakeComplete(int result) {
   if (result < 0)
     return result;
@@ -1264,6 +1284,86 @@ int SSLClientSocketImpl::DoVerifyCert(int result) {
 
   start_cert_verification_time_ = base::TimeTicks::Now();
 
+#if defined(GOSTSSL) && defined(OPENSSL_LINUX)
+#define TRUST_E_CERT_SIGNATURE          0x80096004L
+#define CRYPT_E_REVOKED                 0x80092010L
+#define CERT_E_UNTRUSTEDROOT            0x800B0109L
+#define CERT_E_UNTRUSTEDTESTROOT        0x800B010DL
+#define CERT_E_REVOCATION_FAILURE       0x800B010EL
+#define CERT_E_EXPIRED                  0x800B0101L
+#define CERT_E_INVALID_NAME             0x800B0114L
+#define CERT_E_CN_NO_MATCH              0x800B010FL
+#define CERT_E_VALIDITYPERIODNESTING    0x800B0102L
+#define CRYPT_E_NO_REVOCATION_CHECK     0x80092012L
+#define CRYPT_E_REVOCATION_OFFLINE      0x80092013L
+#define CERT_E_CHAINING                 0x800B010AL
+
+    {
+        static void ( EXPLICITSSL_CALL * verifyhook )( void * ssl, unsigned * gost_status ) = NULL;
+        static int is_tried = 0;
+
+        if( !is_tried )
+        {
+            HMODULE hGSSL = LIBLOAD( GOSTSSLLIB );
+
+            if( hGSSL )
+                *(uintptr_t *)&verifyhook = (uintptr_t)LIBFUNC( hGSSL, "gostssl_verifyhook" );
+
+            is_tried = 1;
+        }
+
+        if( verifyhook )
+        {
+            unsigned gost_status;
+
+            verifyhook( (void *)ssl_.get(), &gost_status );
+
+            if( gost_status )
+            {
+                int gost_rv = OK;
+
+                switch( gost_status )
+                {
+                    case 1:
+                        break;
+                    case CERT_E_CN_NO_MATCH:
+                    case CERT_E_INVALID_NAME:
+                        gost_rv = ERR_CERT_COMMON_NAME_INVALID;
+                        break;
+                    case CERT_E_UNTRUSTEDROOT:
+                    case TRUST_E_CERT_SIGNATURE:
+                    case CERT_E_UNTRUSTEDTESTROOT:
+                    case CERT_E_CHAINING:
+                        gost_rv = ERR_CERT_AUTHORITY_INVALID;
+                        break;
+                    case CERT_E_EXPIRED:
+                    case CERT_E_VALIDITYPERIODNESTING:
+                        gost_rv = ERR_CERT_DATE_INVALID;
+                        break;
+                    case CRYPT_E_NO_REVOCATION_CHECK:
+                    case CERT_E_REVOCATION_FAILURE:
+                        gost_rv = ERR_CERT_NO_REVOCATION_MECHANISM;
+                        break;
+                    case CRYPT_E_REVOCATION_OFFLINE:
+                        gost_rv = ERR_CERT_UNABLE_TO_CHECK_REVOCATION;
+                        break;
+                    case CRYPT_E_REVOKED:
+                        gost_rv = ERR_CERT_REVOKED;
+                        break;
+                    default:
+                        gost_rv = ERR_CERT_INVALID;
+                        break;
+                }
+
+                if( gost_rv != OK )
+                    server_cert_verify_result_.cert_status = MapNetErrorToCertStatus( gost_rv );
+                server_cert_verify_result_.verified_cert = server_cert_;
+                return gost_rv;
+            }
+        }
+    }
+#endif // GOSTSSL && OPENSSL_LINUX
+
   const uint8_t* ocsp_response_raw;
   size_t ocsp_response_len;
   SSL_get0_ocsp_response(ssl_.get(), &ocsp_response_raw, &ocsp_response_len);
@@ -1658,6 +1758,35 @@ int SSLClientSocketImpl::ClientCertRequestCallback(SSL* ssl) {
     return -1;
   }
 
+#if defined(GOSTSSL)
+    if( ssl_config_.client_cert.get() )
+    {
+        static void ( EXPLICITSSL_CALL * certhook )( void * cert, int size ) = NULL;
+        static int is_tried = 0;
+
+        if( !is_tried )
+        {
+            HMODULE hGSSL = LIBLOAD( GOSTSSLLIB );
+
+            if( hGSSL )
+                *(uintptr_t *)&certhook = (uintptr_t)LIBFUNC( hGSSL, "gostssl_certhook" );
+
+            is_tried = 1;
+        }
+
+        if( certhook )
+        {
+#ifdef OPENSSL_WINDOWS
+            certhook( (void *)ssl_config_.client_cert->os_cert_handle(), 0 );
+#else // not OPENSSL_WINDOWS
+            std::string cert_pem;
+            if( ssl_config_.client_cert->GetDEREncoded( ssl_config_.client_cert->os_cert_handle(), &cert_pem ) )
+                certhook( (void *)&cert_pem[0], cert_pem.size() );
+#endif // OPENSSL_WINDOWS
+        }
+    }
+#endif // GOSTSSL
+
   // Second pass: a client certificate should have been selected.
   if (ssl_config_.client_cert.get()) {
     bssl::UniquePtr<X509> leaf_x509 =
diff --git a/net/ssl/client_cert_store_nss.cc b/net/ssl/client_cert_store_nss.cc
index dab4728..36749f0 100644
--- a/net/ssl/client_cert_store_nss.cc
+++ b/net/ssl/client_cert_store_nss.cc
@@ -107,6 +107,16 @@ void ClientCertStoreNSS::FilterCertsOnWorkerThread(
             x509_util::ClientCertSorter());
 }
 
+#define GOSTSSL
+#ifdef GOSTSSL
+#define EXPLICITSSL_CALL
+#include <dlfcn.h>
+#define GOSTSSLLIB "gostssl.so"
+#define LIBLOAD( name ) dlopen( name, RTLD_LAZY )
+#define LIBFUNC( lib, name ) dlsym( lib, name )
+typedef void * HMODULE;
+#endif // GOSTSSL
+
 void ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
     std::unique_ptr<crypto::CryptoModuleBlockingPasswordDelegate>
         password_delegate,
@@ -115,6 +125,42 @@ void ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
   CertificateList platform_certs;
   GetPlatformCertsOnWorkerThread(std::move(password_delegate), &platform_certs);
   FilterCertsOnWorkerThread(platform_certs, *request, selected_certs);
+
+#if defined(GOSTSSL)
+    {
+        static unsigned ( EXPLICITSSL_CALL * clientcertshook )( char *** certs, int ** lens, int * count, int * is_gost ) = NULL;
+        static int is_tried = 0;
+
+        if( !is_tried )
+        {
+            HMODULE hGSSL = LIBLOAD( GOSTSSLLIB );
+
+            if( hGSSL )
+                *(uintptr_t *)&clientcertshook = (uintptr_t)LIBFUNC( hGSSL, "gostssl_clientcertshook" );
+
+            is_tried = 1;
+        }
+
+        if( clientcertshook )
+        {
+            char ** certs;
+            int * lens;
+            int count;
+            int is_gost;
+
+            clientcertshook( &certs, &lens, &count, &is_gost );
+
+            if( is_gost )
+            {
+                selected_certs->clear();
+                for( int i = 0; i < count; i++ )
+                    selected_certs->push_back( X509Certificate::CreateFromBytes( certs[i], lens[i] ) );
+                std::sort( selected_certs->begin(), selected_certs->end(), x509_util::ClientCertSorter() );
+            }
+        }
+    }
+#endif // GOSTSSL
+
 }
 
 // static
diff --git a/net/ssl/openssl_ssl_util.cc b/net/ssl/openssl_ssl_util.cc
index f1266d5..90f6439 100644
--- a/net/ssl/openssl_ssl_util.cc
+++ b/net/ssl/openssl_ssl_util.cc
@@ -77,6 +77,10 @@ int MapOpenSSLErrorSSL(uint32_t error_code) {
     case SSL_R_TLSV1_ALERT_PROTOCOL_VERSION:
     case SSL_R_UNSUPPORTED_PROTOCOL:
       return ERR_SSL_VERSION_OR_CIPHER_MISMATCH;
+#if defined(GOSTSSL)
+    case SSL_R_TLS_GOST_REQUIRED:
+      return ERR_TLS_GOST_REQUIRED;
+#endif // GOSTSSL
     case SSL_R_SSLV3_ALERT_BAD_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED:
diff --git a/net/ssl/ssl_cipher_suite_names.cc b/net/ssl/ssl_cipher_suite_names.cc
index 320c22e..44a03e8 100644
--- a/net/ssl/ssl_cipher_suite_names.cc
+++ b/net/ssl/ssl_cipher_suite_names.cc
@@ -365,6 +365,28 @@ void SSLCipherSuiteToStrings(const char** key_exchange_str,
   *is_aead = false;
   *is_tls13 = false;
 
+#if defined(GOSTSSL)
+  switch( cipher_suite )
+  {
+
+  case 0x81:
+      *key_exchange_str = "GOSTR341001";
+      *cipher_str = "GOST28147CNT";
+      *mac_str = "GOST28147IMIT";
+      return;
+
+  case 0xFF85:
+      *key_exchange_str = "GOSTR341012";
+      *cipher_str = "GOST28147CNT";
+      *mac_str = "GOST28147IMIT";
+      return;
+
+  default:
+      break;
+
+  }
+#endif // GOSTSSL
+
   int key_exchange, cipher, mac;
   if (!GetCipherProperties(cipher_suite, &key_exchange, &cipher, &mac))
     return;
-- 
2.10.0.windows.1

